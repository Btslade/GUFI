gufi - grand unified file indexing
 
The only difference in building programs for linux and macos is where sql is and how xattrs work
so building programs that do xattrs on macos requires -DBSDXATTRS

Support includes/routines:

utils.c print and other utilities
dbutils.c database helper utilities
bf.h common .h
structq.c helpers for queues needed for breadth first queueing

Programs:

dfw - depth first walk - a typical depth first tree walker that uses readdir or readdir+ (getting type from dirent), stat (to get stat info and type (if not readdir+)), and xattr calls, single threaded, recursive depth search, prints output
parms - path 0/1 (0 use readdir+ 1 use stat) 0/1 (0 dont get xattrs 1 get xattrs)

cc dfw.c -o dfw
cc bfw.c -DBSDXATTRS -o bfw
echo "---> ./dfw testdir 0 0 (just walk with readdir)"
./dfw testdir 0 0
echo "---> ./dfw testdir 1 0 (just walk with stat)"
./dfw testdir 1 0
echo "---> ./dfw testdir 1 1 (walk with stat and xattr)"
./dfw testdir 1 1

dfwrplus - depth first readdirplus walk (no stat or xattrs at all) output is path, type, inode, pinode (parent inode), single threaded
cc dfwrplus.c -o dfwrplus
./dfwrplus testdir

dfwrplusdb - depth first readdirplus walk (no stat or xattrs at all) output is path,type,inode,pinode loads into hard coded sqlite3 db "readdirplus.db" with inode as primary index, single threaded, inserts in batches
parms - path 
cc dfwrplusdb.c -o dfwrplusdb
./dfwrplusdb testdir

dfwrplusdbthread - depth first readdirplus walk (no stat or xattrs at all) output is path,type,inode,pinode loads into hard coded sqlite3 db "readdirplus.db" with inode as primary index, two threads, a readdir+ thread and a db insert thread inserts in batches 
parms - path 
cc dfwrplusdbthread.c -o dfwrplusdbthread
./dfwrplusdbthread testdir

dfwrplusdbthreadsort - depth first readdirplus walk (no stat or xattrs at all) output is path,type,inode,pinode loads into hard coded sqlite3 db "readdirplus.db" with inode as primary index, two threads, a readdir+ thread and a db insert thread inserts in batches, sorts batches by inode so db inserts are sorted by inode (in batches) 
**** should collaps dfwrplus, dfwrplusdb, dfwrplusdbthread, dfwrplusdbthreadsort into one using dfwrplusdbthreadsort and some input parms
parms - path 
cc rpluslistdbthreadsort.c -I.. -L../.libs -l sqlite3 -DBSDXATTRS -o rpluslistdbthreadsort
./dfwrplusdbthreadsort testdir

bfw - breadth first walker, threaded, queue used to hold directories to be worked, as threads encounter directories they queue them to the master thread who hands them out as threads get free, zero threads is serial which may be needed if you want an in dir order output (as threads will be async)  
parms - path, printout or not, number of threads, use special space delim or not)
cc bfw.c -o bfw
cc bfw.c -pthread -o bfw
echo "---> ./bfw testdir 1 10 0 (walk with readdir stat and xattr print 10 threads  no spacedelim)"
./bfw testdir 0 0 0
echo "---> ./bfw testdir 0 10 1 (walk with readdir stat and xattr print 10 threads use spacedelim)"
./bfw testdir 1 0 0

bfi - breadth first walker index builder, threaded, queue used to hold directories to be worked, as threads encounter directories they queue them to the master thread who hands them out as threads get free, zero threads is serial which may be needed if you want an in dir order output (as threads will be async) - makes a gufi index from the source tree input with on entries db and one directory summary db per directory
parms - input tree outputtree printout numthreads
cc bfi.c -I.. -L../.libs -DBSDXATTRS -l sqlite3 -o bfi
cc bfi.c -pthread -l sqlite3 -o bfi
rm -rf testdirdup1
mkdir testdirdup1
./bfi testdir testdirdup1 1 5

bfli - takes the output of a bfw (with delimiter) and builds a gufi index, threaded, queue used to hold directories to be worked, as threads encounter directories they queue them to the master thread who hands them out as threads get free, zero threads is serial which may be needed if you want an in dir order output (as threads will be async) - makes a gufi index from a breadth first dump the source tree, the resulting gufi index has the typical  entries db and one directory summary db per directory
cc bfli.c -I.. -L../.libs -l sqlite3 -DBSDXATTRS -o bfli
parms - inputfile (bf list of input tree), output treename, printout, numthreads (zero threads is serial)
./bfli dump testdirdup5 1 0

bfti - makes a tree index at a particular level of a gufi tree, it walks the gufi index below the input level and queries the directory summaries and builds a tree summary index that represents the entire tree below the input level
parms - level at which you want the tree summary index, printout, num threads, write the tree index or just print (1 for write)
./bfti testdirdup1/testdir  0 30 1

dbdump - print the information out of a tree summary index
parms - directory name where tree summary lives, print entry info for that dir as well as tree summary info

bfq - threaded query of a gufi tree, has 3 sql statements, one that is used to limit results using the tree indexes, 
one that is used to limit the results using the directory summary indexes, and one that is used to limit the results using the 
entries indexes.  it walks the tree in breadth first search and threads out directories and runs sql for each dir all in parallel
cc bfq.c -I.. -L../.libs -DBSDXATTRS -l sqlite3 -o bfq
cc bfq.c -pthread -l sqlite3 -o bfq
#
# ./bfq path reserved "select on summary" "select on entries" printdirresults andor printdirsexamined
# printdirresults prints the directory info if it matches critera
# andor 0 is and 1 is or - and or between first select and second select
# printdirsexamined printes each directory that is examined
# maxthreads
# put pinode in column
#
echo ">>>>>>>>> summary like cc entries like dumb printdir or printdirexamined"
./bfq testdirdup1/testdir "" "select name,type,uid,gid,size from summary where name like '%cc%'" "select name,type,uid,gid,size from entries where name like '%dumb%'" 1 1 1 4 0
echo ">>>>>>>>> no summary entries like dumb noprintdir or noprintdirexamined"
./bfq testdirdup1/testdir "" "" "select name,type,uid,gid,size from entries where name like '%dumb%'"  0 0 0 4 0
echo ">>>>>>>>> test of printing parent inodes in 4 column"
./bfq testdirdup1/testdir "" "select name,type,inode,uid,gid,size from summary" "select name,type,inode,uid,gid,size from entries"  1 0 0 0 4
echo ">>>>>>>>> test of printing parent inode in 4 column using tree summary max files in dir > 1"
./bfq testdirdup1/testdir "select maxsubdirfiles from treesummary where maxsubdirfiles > 1" "select name,type,inode,uid,gid,size from summary" "select name,type,inode,uid,gid,size from entries"  1 0 0 0 4
echo ">>>>>>>>> test of printing parent inode in 4 column using tree summary max files in dir > 10"
./bfq testdirdup1/testdir "select maxsubdirfiles from treesummary where maxsubdirfiles > 10" "select name,type,inode,uid,gid,size from summary" "select name,type,inode,uid,gid,size from entries"  1 0 0 0 4

bffuse - a simple fuse file system that you can start, it directory summary query and entries query from files and uses those to govern how readdir and stat(getattr) work so you only see the query's results in your file system
# edit bffuse.c and change location of summary.query and entries.query currently located in /tmp  and global mount point top level dir currently located in testdirdup1 (tmp must have entries.db and summary.db
cc bffuse.c -I /usr/local/include/osxfuse -D_FILE_OFFSET_BITS=64 -I.. -L../.libs -l sqlite3 -L /usr/local/lib -l osxfuse -o bffuse 
cp summary.query /tmp
echo "/tmp/summary.query:"
cat /tmp/summary.query
cp entries.query /tmp
echo "/tmp/entries.query:"
cat /tmp/entries.query
# run fuse in debug mode and then start another window and do an ls /tmp/mnt
./bffuse /tmp/mnt -d
# to stop fuse you may have to ps -ef | grep bffuse and kill that pid and
#umount -f /tmp/mnt

rpluslistdbthreadsort - does readdirplus walk of tree and writes a single sqlite3 db that has path, type, inode, pinode into a hard coded path gpfsfull.db with inode as primary key,thread for readdir and thread for sort/insert, sorted/inserted in batches, used to potentially do a gpfs readdirplus walk to create a psuedo inode sorted db to merge with an inode scan (full or incremental)
parms - input tree
rpluslistdbthreadsort testdir`

bfhi - breadth first hpss nsobj db walker index builder, threaded, queue used to hold directories to be worked, as threads encounter directories they queue them to the master thread who hands them out as threads get free, zero threads is serial which may be needed if you want an in dir order output (as threads will be async) - makes a gufi index from the source tree input with on entries db and one directory summary db per directory
parms - inputdb outputtree printout numthreads
cc bfhi.c -I.. -L../.libs -DBSDXATTRS -l sqlite3 -o bfhi
cc bfhi.c -pthread -l sqlite3 -o bfhi

